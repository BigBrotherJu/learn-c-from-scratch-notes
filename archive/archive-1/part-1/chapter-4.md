# 4. 分支语句

## 4.1 if 语句

除了顺序执行之外，有时候我们需要检查一个条件，然后根据检查的结果执行不同的后续代码，在 C 语言中可以用分支语句（Selection Statement）实现。

比如：

``` c
if (x != 0) {
	  printf("x is nonzero.\n");
}
```

- 控制表达式

  其中 `x != 0` 表示「x 不等于 0」的条件，这个表达式称为控制表达式（Controlling Expression）。

  如果控制表达式值非 0，则 `{}` 中的语句被执行，否则 `{}` 中的语句不执行，直接跳到 `}` 后面。

  `if` 和控制表达式改变了程序的控制流程（Control Flow），不再是从前到后顺序执行，而是根据不同的条件执行不同的语句，这种控制流程称为分支（Branch）。

- 相等性运算符（Equality Operator）和关系运算符（Relational Operator）

  `==` 和 `!=` 称为相等性运算符（Equality Operator），`>` `>=` `<` `<=` 称为关系运算符（Relational Operator），相等性运算符的优先级低于关系运算符。

  以上几种运算符都是左结合的。

  - 操作数

    这些运算符的两个操作数应该是相同类型的，两边都是整型或者都是浮点型可以做比较，但两个字符串不能做比较，在第 1.5 节「比较字符串」我们会介绍比较字符串的方法。

- 控制表达式的值

  控制表达式所表示的比较关系成立则值为真（True），否则为假（False），在 C 语言中分别用 `int` 型的 1 和 0 表示。

  如果变量 `x` 的值是 -1，那么 `x>0` 这个表达式的值为 0，`x>-2` 这个表达式的值为 1。

- if 语句语法规则

  ```
  语句 → if (控制表达式) 语句
  语句 → { 语句列表 }
  语句 → ;
  ```

### 语句块和空语句

在 C 语言中，任何允许出现语句的地方既可以是由 `;` 号结尾的一条语句，也可以是由 `{}` 括起来的若干条语句或声明组成的语句块（Statement Block），语句块和上一章介绍的函数体的语法相同。

注意语句块的 `}` 后面不需要加 `;` 号。如果 `}` 后面加了 `;` 号，则这个 `;` 号本身又是一条新的语句了，在 C 语言中一个单独的 `;` 号表示一条空语句（Null Statement）。

上例的语句块中只有一条语句，其实没必要写成语句块，可以简单地写成：

``` c
if (x != 0)
	  printf("x is nonzero.\n");
```

- 语句块定义局部变量

  语句块中也可以定义局部变量，例如：

  ``` c
  void foo(void)
  {
      int i = 0;
      {
          int i = 1;
          int j = 2;
          printf("i=%d, j=%d\n", i, j);
      }
      printf("i=%d\n", i); /* cannot access j here */
  }
  ```

  和函数的局部变量同样道理，每次进入语句块时为变量 `j` 分配存储空间，每次退出语句块时释放变量 `j` 的存储空间。

  语句块也构成一个作用域，和例 3.6「作用域」的分析类似，如果整个源文件是一张大纸，`foo` 函数是盖在上面的一张小纸，则函数中的语句块是盖在小纸上面的一张更小的纸。

  语句块中的变量 `i` 和函数的局部变量 `i` 是两个不同的变量，因此两次打印的 `i` 值是不同的；语句块中的变量 `j` 在退出语句块之后就没有了，因此最后一行的 `printf` 不能打印变量 `j`，否则编译器会报错。

  语句块可以用在任何允许出现语句的地方，不一定非得用在 if 语句中，单独使用语句块通常是为了定义一些比函数的局部变量更「局部」的变量。

## 4.2 if/else 语句

### else 子句

if 语句还可以带一个 else 子句（Clause），例如：

```
if (x % 2 == 0)
	  printf("x is even.\n");
else
	  printf("x is odd.\n");
```

### 取模运算符

这里的 % 是取模（Modulo）运算符，`x%2` 表示 `x` 除以 2 所得的余数（Remainder），C 语言规定 `%` 运算符的两个操作数必须是整型的。

- 结果符号与被除数同号

  两个正数相除取余数很好理解，如果操作数中有负数，结果应该是正是负呢？

  C99 规定，如果 `a` 和 `b` 是整型，`b` 不等于 0，则表达式 `(a/b)*b+a%b` 的值总是等于 `a`，再结合第 5 节「表达式」讲过的整数除法运算要 Truncate Toward Zero，可以得到一个结论：% 运算符的结果总是与被除数同号（想一想为什么）。

  其它编程语言对取模运算的规定各不相同，也有规定结果和除数同号的，也有不做明确规定的。

### if/else 语句语法规则

```
语句 → if (控制表达式) 语句 else 语句
```

右边的「语句」既可以是一条语句，也可以是由 `{}` 括起来的语句块。

### 嵌套

一条 if 语句中包含一条子语句，一条 if/else 语句中包含两条子语句，子语句可以是任何语句或语句块，当然也可以是另外一条 if 或 if/else 语句。

根据组合规则，if 或 if/else 可以嵌套使用。例如可以这样：

``` c
if (x > 0)
	  printf("x is positive.\n");
else if (x < 0)
	  printf("x is negative.\n");
else
	  printf("x is zero.\n");
```

也可以这样：

``` c
if (x > 0) {
	  printf("x is positive.\n");
} else {
	  if (x < 0)
		    printf("x is negative.\n");
	  else
		    printf("x is zero.\n");
}
```

- Dangling-else 问题

  else 总是和它上面最近的 if 配对。

### 浮点型精度有限

顺便提一下，浮点型的精度有限，不适合用 `==` 运算符做精确比较。

以下代码可以说明问题：

``` c
double i = 20.0;
double j = i / 7.0;
if (j * 7.0 == i)
	  printf("Equal.\n");
else
	  printf("Unequal.\n");
```

不同平台的浮点数实现有很多不同之处，在我的平台上运行这段程序结果为 `Unequal`，即使在你的平台上运行结果为 `Equal`，你再把 `i` 改成其它值试试，总有些值会使得结果为 `Unequal`。

等学习了第 4 节「浮点数」你就知道为什么浮点型不能做精确比较了。

## 4.3 布尔代数

### 逻辑运算符

我们可以用逻辑与（Logical AND）运算符表示这两个条件同时成立。

逻辑与运算符在 C 语言中写成两个 & 号（Ampersand）。

`x && y` 要求 `x` 非 0 和 `y` 非 0 这两个条件同时成立时，这个控制表达式的值才是 1，否则就是 0。

C 语言还提供了逻辑或（Logical OR）运算符，写成两个 | 线（Pipe Sign），逻辑非（Logical NOT）运算符，写成一个 ! 号（Exclamation Mark）。

### 单目运算符与双目运算符

逻辑非运算符只有一个操作数，称为单目运算符（Unary Operator），以前讲过的加减乘除、赋值、相等性、关系、逻辑与、逻辑或运算符都有两个操作数，称为双目运算符（Binary Operator）。

### 布尔类型

在编程语言中表示真和假的数据类型叫做布尔类型，在 C 语言中通常用 `int` 型来表示，非 0 表示真，0 表示假。

C99 也定义了专门的布尔类型 `_Bool`，但目前没有被广泛使用。

### 目前运算符优先级

! 高于 * / %，高于 + -，高于 > < >= <=，高于 == !=，高于 &&，高于 ||，高于 =。

写一个控制表达式很可能同时用到这些运算符中的多个，如果记不清楚运算符的优先级一定要多套括号。

我们将在第 4 节「运算符总结」总结 C 语言所有运算符的优先级和结合性。

## 4.4 switch 语句

switch 语句可以产生具有多个分支的控制流程。

它的格式是：

```
switch (控制表达式) {
case 常量表达式： 语句列表
case 常量表达式： 语句列表
...
default： 语句列表
}
```

- `break`

  `break` 语句的作用是跳出整个 `switch` 语句块。

- 各 case 分支的常量表达式必须互不相同

  C 语言规定各 case 分支的常量表达式必须互不相同。

- `default`

  如果控制表达式不等于任何一个常量表达式，则从 `default` 分支开始执行，通常把 `default` 分支写在最后，但不是必须的。

- case 后面必须是常量表达式

  case 后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在**编译时计算出来**。

- case 后面跟整型常量表达式

  第 2 节「if/else 语句」讲过浮点型不适合做精确比较，所以 C 语言规定 case 后面跟的必须是整型常量表达式。

- 不遇到 `break` 一直往下执行

  进入 case 后如果没有遇到 break 语句就会一直往下执行，后面其它 case 或 default 分支的语句也会被执行到，直到遇到 break，或者执行到整个 switch 语句块的末尾。

  通常每个 case 后面都要加上 break 语句，但有时会故意不加 break 来利用这个特性。

- switch 语句和 if/else 语句比较

  switch 语句不是必不可缺的，显然可以用一组 `if ... else if ... else if ... else ...` 代替，但是一方面用 switch 语句会使代码更清晰，另一方面，有时候编译器会对 switch 语句进行整体优化，使它比等价的 if/else 语句所生成的指令效率更高。
