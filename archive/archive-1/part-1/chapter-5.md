# 5. 深入理解函数

## 5.1 return 语句

### return 语句使用场景

- 有返回值的函数

  在有返回值的函数中，return 语句的作用是提供整个函数的返回值，并结束当前函数返回到调用它的地方。

  有返回值的函数如果没有 return 语句，C 语言对于这种情况会返回什么结果是未定义的，通常返回不确定的值。

- 没有返回值的函数

  在没有返回值的函数中也可以使用 return 语句，例如当检查到一个错误时提前结束当前函数的执行并返回。

  没有返回值的函数中也可以没有 return 语句，函数中所有的语句都会被执行，到达函数体的末尾，然后返回。

### `return (...);`

有些人喜欢写成 `return (1);`，这种形式也可以，表达式外面套括号表示改变运算符优先级，在这里不起任何作用。

### 函数返回值的理解

函数返回一个值相当于在调用这个函数的函数体中定义一个和返回值类型相同的临时变量并用 return 后面的表达式来初始化。

- 函数调用表达式不能做左值

  虽然函数的返回值可以看作是一个临时变量，但我们只是读一下它的值，读完值就释放它，而不能往它里面存新的值，换句话说，函数的返回值不是左值，或者说函数调用表达式不能做左值，因此下面的赋值语句是非法的：

  ``` c
  is_even(20) = 1;
  ```

- 返回值也是按值传递

  在第 3 节「形参和实参」中讲过，C 语言的传参规则是 Call by Value，按值传递，现在我们知道返回值也是按值传递的，即便返回语句写成 `return x;`，返回的也是变量 `x` 的值，而非变量 `x` 本身，因为变量 `x` 马上就要被释放了。

### 代码路径

在写带有 return 语句的函数时要小心检查所有的代码路径（Code Path）。

- 多的代码路径

  有些代码路径在任何条件下都执行不到，这称为 Dead Code。

  有 Dead Code 就一定有 Bug，你写的每一行代码都是想让程序在某种情况下去执行的，你不可能故意写出一行永远不会被执行的代码，如果程序在任何情况下都不会去执行它，说明跟你预想的不一样。

- 少的代码路径

  还有一些时候，对程序中所有可能的情况分析得不够全面将导致漏掉一些代码路径。

## 5.2 增量式开发

- Scaffold

  像打印语句，以及我们用来测试的 `main` 函数，都起到了类似脚手架（Scaffold）的作用：在盖房子时很有用，但它不是房子的一部分，房子盖好之后就可以拆掉了。

  房子盖好之后可能还需要维修、加盖、翻新，又要再加上脚手架，这很麻烦，要是当初不用拆就好了，可是不拆不行，不拆多难看啊。

  写代码却可以有一个更高明的解决办法：把 Scaffolding 的代码注释掉。

- 增量式开发

  增量式（Incremental）开发非常适合初学者，每写一行代码都编译运行，确保没问题了再写一下行，一方面在写代码时更有信心，另一方面也方便了调试：总是有一个先前的正确版本做参照，改动之后如果出了问题，几乎可以肯定就是刚才改的那行代码出的问题，这样就避免了必须从很多行代码中查找分析到底是哪一行出的问题。

  在这个过程中 `printf` 功不可没，你怀疑哪一行代码有问题，就插一个 `printf` 进去看看中间的计算结果，任何错误都可以通过这个办法找出来。

  以后我们会介绍程序调试工具 `gdb`，它提供了更强大的调试功能帮你分析更隐蔽的错误。但即使有了 `gdb`，`printf` 这个最原始的办法仍然是最直接、最有效的。

- 函数的复用

  尽可能复用（Reuse）以前写的代码，避免写重复的代码。

  封装就是为了复用，把解决各种小问题的代码封装成函数，在解决第一个大问题时可以用这些函数，在解决第二个大问题时可以复用这些函数。

- 函数的分层设计

  解决问题的过程是把大的问题分成小的问题，小的问题再分成更小的问题，这个过程在代码中的体现就是函数的分层设计（Stratify）。

  `distance` 和 `area` 是两个底层函数，解决一些很小的问题，而 `area_point` 是一个上层函数，上层函数通过调用底层函数来解决更大的问题，底层和上层函数都可以被更上一层的函数调用，最终所有的函数都直接或间接地被 `main` 函数调用。

## 5.3 递归

### 递归相关

- 什么是递归

  如果定义一个概念需要用到这个概念本身，我们称它的定义是递归的（Recursive）。

- 递归函数

  自己直接或间接调用自己的函数称为递归函数。这里的 `factorial` 是直接调用自己，有些时候函数 A 调用函数 B，函数 B 又调用函数 A，也就是函数 A 间接调用自己，这也是递归函数。

- 栈、栈顶和栈帧

  我们看上图右侧存储空间的变化过程，随着函数调用的层层深入，存储空间的一端逐渐增长，然后随着函数调用的层层返回，存储空间的这一端又逐渐缩短，并且每次访问参数和局部变量时只能访问这一端的存储单元，而不能访问内部的存储单元，比如当 `factorial(2)` 的存储空间位于末端时，只能访问它的参数和局部变量，而不能访问 `factorial(3)` 和 `main()` 的参数和局部变量。

  具有这种性质的数据结构称为堆栈或栈（Stack），随着函数调用和返回而不断变化的这一端称为栈顶，每个函数调用的参数和局部变量的存储空间（上图的每个小方框）称为一个栈帧（Stack Frame）。

  操作系统为程序的运行预留了一块栈空间，函数调用时就在这个栈空间里分配栈帧，函数返回时就释放栈帧。

- Leap of Faith

  在写一个递归函数时，你如何证明它是正确的？

  像上面那样跟踪函数的调用和返回过程算是一种办法，但只是 `factorial(3)` 就已经这么麻烦了，如果是 `factorial(100)` 呢？

  虽然我们已经证明了 `factorial(3)` 是正确的，因为它跟我们用数学公式计算的过程一样，结果也一样，但这不能代替 `factorial(100)` 的证明，你怎么办？

  别的函数你可以跟踪它的调用过程去证明它的正确性，因为每个函数只调用一次就返回了，但是对于递归函数，这么跟下去只会跟得你头都大了。

  事实上并不是每个函数调用都需要钻进去看的。我们在调用 `printf` 时没有钻进去看它是怎么打印的，我们只是**相信**它能打印，能正确完成它的工作，然后就继续写下面的代码了。

  在上一节中，我们写了 `distance` 和 `area` 函数，然后立刻测试证明了这两个函数是正确的，然后我们写 `area_point` 时调用了这两个函数。

  在写 `area_point` 函数时，我们需要钻进 `distance` 和 `area` 函数中去走一趟才知道我们调用得是否正确吗？不需要，因为我们已经相信这两个函数能正确工作了，也就是相信把座标传给 `distance` 它就能返回正确的距离，把半径传给 `area` 它就能返回正确的面积，因此调用它们去完成另外一件工作也应该是正确的。

  这种「相信」称为 Leap of Faith，首先相信一些结论，然后再用它们去证明另外一些结论。

  在写 `factorial(n)` 的代码时写到这个地方：

  ```
  ...
  int recurse = factorial(n-1);
  int result = n * recurse;
  ...
  ```

  这时，如果我们相信 `factorial(n-1)` 是正确的，也就是相信传给它 `n-1` 它就能返回 `(n-1)!`，那么 `recurse` 就是 `(n-1)!`，那么 `result` 就是 `n*(n-1)!`，也就是 `n!`，这正是我们要返回的 `factorial(n)` 的结果。

  当然这有点奇怪：我们还没写完 `factorial` 这个函数，凭什么要相信 `factorial(n-1)` 是正确的？可 Leap of Faith 本身就是 Leap（跳跃）的，不是吗？如果你相信你正在写的递归函数是正确的，并调用它，然后在此基础上写完这个递归函数，那么它就会是正确的，从而值得你相信它正确。

  这么说好像有点儿玄，我们从数学上严格证明一下 `factorial` 函数的正确性。刚才说了，`factorial(n)` 的正确性依赖于 `factorial(n-1)` 的正确性，只要后者正确，在后者的结果上乘个 `n` 返回这一步显然也没有疑问，那么我们的函数实现就是正确的。因此要证明 `factorial(n)` 的正确性就是要证明 `factorial(n-1)` 的正确性，同理，要证明 `factorial(n-1)` 的正确性就是要证明 `factorial(n-2)` 的正确性，依此类推下去，最后是：要证明 `factorial(1)` 的正确性就是要证明 `factorial(0)` 的正确性。而 `factorial(0)` 的正确性不依赖于别的函数调用，它就是程序中的一个小的分支 `return 1;`，这个 1 是我们根据阶乘的定义写的，肯定是正确的，因此 `factorial(1)` 的实现是正确的，因此 `factorial(2)` 也正确，依此类推，最后 `factorial(n)` 也是正确的。其实这就是在中学时学的数学归纳法（Mathematical Induction）。

- Base Case 和递推关系都要正确

  用数学归纳法来证明只需要证明两点：Base Case 正确，递推关系正确。

- 如果没写 Base Case，就是无穷递归

  写递归函数时一定要记得写 Base Case，否则即使递推关系正确，整个函数也不正确。

  如果 `factorial` 函数漏掉了 Base Case，那么这个函数就会永远调用下去，直到操作系统为程序预留的栈空间耗尽程序崩溃（段错误）为止，这称为无穷递归（Infinite recursion）。

### 目前语法子集

- 目前语法子集已经完备

  到目前为止我们只学习了全部 C 语法的一个小的子集，但是现在应该告诉你：这个子集是**完备**的，它本身就可以作为一门编程语言了。

- 已经要学的新特性不是必不可少的

  以后还要学习很多 C 语言特性，但全部都可以用已经学过的这些特性来代替。

  也就是说，以后要学的 C 语言特性会使代码写起来更加方便，但不是必不可少的。

  现在学的这些已经完全覆盖了第 1 节「程序和编程语言」讲的五种基本指令了。

- 循环和递归是等价的，有些编程语言只有递归

  有的读者会说循环还没讲到呢，是的，循环在下一章才讲，但有一个重要的结论就是递归和循环是等价的，用循环能做的事用递归都能做，反之亦然，事实上有的编程语言（比如某些 LISP 实现）只有递归而没有循环。

- 为什么计算机只有五种基本指令

  计算机指令能做的所有事情就是数据存取、运算、测试和分支、循环（或递归），在计算机上运行高级语言写的程序最终也要翻译成指令，指令做不到的事情高级语言写的程序肯定也做不到，虽然高级语言有丰富的语法特性，但也只是比指令写起来更方便而已，能做的事情是一样多的。

  那么，为什么计算机要设计成这样？在设计时怎么想到计算机应该具备这几样功能，而不是更多或更少的功能？这些要归功于早期的计算机科学家，例如 Alan Turing，他们在计算机还没有诞生的年代就从数学理论上为计算机的设计指明了方向。有兴趣的读者可以参考有关计算理论的教材，例如 IATLC。

### 递归的重要性

递归绝不只是为解决一些奇技淫巧的数学题而想出来的招，它是计算机的精髓所在，也是编程语言的精髓所在。

- 语法中的递归体现

  我们学习在 C 的语法时已经看到很多递归定义了，例如在第 1 节 「数学函数」讲过的语法规则中，「表达式」就是递归定义的：

  ```
  表达式 → 表达式(参数列表)
  参数列表 → 表达式, 表达式, ...
  ```

  再比如在第 1 节「if 语句」讲过的语规则中，「语句」也是递归定义的：

  ```
  语句 → if (控制表达式) 语句
  ```

  可见编译器在解析我们写的程序时一定也用了大量的递归，有关编译器的实现原理可参考 Dragon Book。
