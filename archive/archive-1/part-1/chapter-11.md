# 11. 排序与查找

## 11.1 算法的概念

- 算法是什么

  算法（Algorithm）是将一组输入转化成一组输出的一系列计算步骤，其中每个步骤必须能在有限时间内完成。

- 算法用来解决一类问题

  算法是用来解决一类计算问题的，注意是一类问题，而不是一个特定的问题。

  例如，一个排序算法应该能对任意一组数据进行排序，而不是仅对 int a[] = { 1, 3, 4, 2, 6, 5 }; 这样一组数据排序，如果只需要对这一组数据排序可以写这样一个函数来做：

  ```
  void sort(void)
  {
    a[0] = 1;
    a[1] = 2;
    a[2] = 3;
    a[3] = 4;
    a[4] = 5;
    a[5] = 6;
  }
  ```

  这显然不叫算法，因为不具有通用性。

  由于算法是用来解决一类问题的，它必须能够正确地解决这一类问题中的任何一个实例，这个算法才是正确的。

  对于排序算法，任意输入一组数据，它必须都能输出正确的排序结果，这个排序算法才是正确的。

- 不正确的算法有两种可能

  不正确的算法有两种可能，一是对于该问题的某些输入，该算法会无限计算下去，不会终止，二是对于该问题的某些输入，该算法终止时输出的是错误的结果。

- 不正确的算法也是有用的

  有时候不正确的算法也是有用的，如果对于某个问题寻求正确的算法很困难，而某个不正确的算法可以在有限时间内终止，并且能把误差控制在一定范围内，那么这样的算法也是有实际意义的。

  例如有时候寻找最优解的开销很大，往往会选择能给出次优解的算法。

## 11.2 插入排序

- Loop Invariant

## 11.3 算法的时间复杂度分析

- 语句的执行时间

  受内存管理机制的影响，指令的执行时间不一定是常数，但执行时间的上界（Upper Bound）肯定是常数，我们这里假设语句的执行时间是常数只是一个粗略估计。

- 算法的执行情况

  - 最好情况
  - 平均情况
  - 最坏情况

- 分析算法时间复杂度时，我们更关心最坏情况

  在分析算法的时间复杂度时，我们更关心最坏情况而不是最好情况，理由如下：

  1. 最坏情况给出了算法执行时间的上界，我们可以确信，无论给什么输入，算法的执行时间都不会超过这个上界，这样为比较和分析提供了便利。

  2. 对于某些算法，最坏情况是最常发生的情况，例如在数据库中查找某个信息的算法，最坏情况就是数据库中根本不存在该信息，都找遍了也没有，而某些应用场合经常要查找一个信息在数据库中存在不存在。

  3. 虽然最坏情况是一种悲观估计，但是对于很多问题，平均情况和最坏情况的时间复杂度差不多，比如插入排序这个例子，平均情况和最坏情况的时间复杂度都是输入长度 n 的二次函数。

- 朴素的比较多项式增长速度的看法

  比较两个多项式 a<sub>1</sub>n+b<sub>1</sub>和a<sub>2</sub>n<sup>2</sup>+b<sub>2</sub>n+c<sub>2</sub>的值（n 取正整数）可以得出结论：n 的最高次指数是最主要的决定因素，常数项、低次幂项和系数都是次要的。

  比如 100n+1 和 n<sup>2</sup>+1，虽然后者的系数小，当 n 较小时前者的值较大，但是当 n>100 时，后者的值就远远大于前者了。

  如果同一个问题可以用两种算法解决，其中一种算法的时间复杂度为线性函数，另一种算法的时间复杂度为二次函数，当问题的输入长度 n 足够大时，前者明显优于后者。

  因此我们可以用一种更粗略的方式表示算法的时间复杂度，把系数和低次幂项都省去，线性函数记作 Θ(n)，二次函数记作 Θ(n<sup>2</sup>)。

- Θ(g(n))：同一量级

  Θ(g(n)) 表示和 g(n) 同一量级的一类函数，例如所有的二次函数 f(n) 都和 g(n)=n<sup>2</sup> 属于同一量级，都可以用 Θ(n<sup>2</sup>) 来表示，甚至有些不是二次函数的也和 n<sup>2</sup> 属于同一量级，例如 2 n<sup>2</sup>+3lgn。

  如果可以找到两个正的常数c<sub>1</sub>和c<sub>2</sub>，使得 n 足够大的时候（也就是 n≥n<sub>0</sub> 的时候）f(n) 总是夹在 c<sub>1</sub>g(n) 和 c<sub>2</sub>g(n) 之间，就说 f(n) 和 g(n) 是同一量级的，f(n) 就可以用 Θ(g(n)) 来表示。

- 常见的时间复杂度函数

  几种常见的时间复杂度函数按数量级从小到大的顺序依次是：Θ(lgn)，Θ(sqrt(n))，Θ(n)，Θ(nlgn)，Θ(n<sup>2</sup>)，Θ(n<sup>3</sup>)，Θ(2<sup>n</sup>)，Θ(n!)。

  其中，lgn 通常表示以 10 为底 n 的对数，但是对于 Θ-notation 来说，Θ(lgn) 和 Θ(log<sub>2</sub>n)并无区别（想一想这是为什么），在算法分析中 lgn 通常表示以 2 为底 n 的对数。

  可是什么算法的时间复杂度里会出现 lgn 呢？回顾插入排序的时间复杂度分析，无非是循环体的执行时间乘以循环次数，只有加和乘运算，怎么会出来 lg 呢？下一节归并排序的时间复杂度里面就有 lg，请读者留心 lg 运算是从哪出来的。

- O(g(n))

  除了 Θ-notation 之外，表示算法的时间复杂度常用的还有一种 Big-O notation。

  我们知道插入排序在最坏情况和平均情况下时间复杂度是 Θ(n<sup>2</sup>)，在最好情况下是 Θ(n)，数量级比 Θ(n<sup>2</sup>) 要小，那么总结起来在各种情况下插入排序的时间复杂度是O(n<sup>2</sup>)。

  Θ 的含义和「等于」类似，而大 O 的含义和「小于等于」类似。

## 11.4 归并排序

## 11.5 线性查找

## 11.6 折半查找

- Loop Invariant

- Design by Contract: precondition, maintain invariant, postcondition

  注意这个算法有一个非常重要的前提——a 是排好序的。缺了这个前提，「如果 `a[mid]` < number，那么 `a[start..mid]` 应该都比 number 小」这一步推理就不能成立，这个函数就不能正确地完成查找。

  从更普遍的意义上说，函数的调用者（Caller）和函数的实现者（Callee，被调用者）之间订立了一个契约（Contract）。

  在调用函数之前，Caller 要为 Callee 提供某些条件，比如确保 a 是排好序的，确保 `a[start..end]` 都是有效的数组元素而没有访问越界，这称为 Precondition。

  然后 Callee 对一些 Invariant 进行维护（Maintenance），这些 Invariant 保证了 Callee 在函数返回时能够对 Caller 尽到某些义务，比如确保「如果 number 在数组 a 中存在，一定能找出来并返回它的位置，如果 number 在数组 a 中不存在，一定能返回 -1」，这称为 Postcondition。

  如果每个函数的文档都非常清楚地记录了 Precondition、Maintenance 和 Postcondition 是什么，那么每个函数都可以独立编写和测试，整个系统就会易于维护。

  这种编程思想是由 Eiffel 语言的设计者 Bertrand Meyer 提出来的，称为 Design by Contract（DbC）。

- 测试一个函数

  测试一个函数是否正确需要把 Precondition、Maintenance 和 Postcondition 这三方面都测试到。

  比如 binarysearch 这个函数，即使它写得非常正确，既维护了 Invariant 也保证了 Postcondition，如果调用它的 Caller 没有保证 Precondition，最后的结果也还是错的。

- 用简单代码去测试负责代码

  也许有人会问：我们用几个测试函数来测试 binarysearch，那么这几个测试函数又用什么来测试呢？在实际工作中我们要测试的代码绝不会像 binarysearch 这么简单，而我们编写的测试函数往往都很简单，比较容易保证正确性，也就是用简单的、不容易出错的代码去测试复杂的、容易出错的代码。

- assert

  assert 是头文件 assert.h 中的一个宏定义，执行到 assert(is_sorted()) 这句时，如果 is_sorted() 返回值为真，则当什么事都没发生过，继续往下执行，如果 is_sorted() 返回值为假（例如把数组的排列顺序改一改），则报错退出程序。

  在代码中适当的地方使用断言（Assertion）可以有效地帮助我们测试程序。

  - `#define NDEBUG`

    测试代码只在开发和调试时有用，如果正式发布（Release）的软件也要运行这些测试代码就会严重影响性能了，如果在包含 assert.h 之前定义一个 NDEBUG 宏（表示 No Debug），就可以禁用 assert.h 中的 assert宏 定义，这样代码中的所有 assert 测试都不起作用了：

    ``` c
    #define NDEBUG
    #include <stdio.h>
    #include <assert.h>
    ...
    ```

    注意 NDEBUG 和我们以前使用的宏定义有点不同，例如 #define N 20 将 N 定义为 20，在预处理时把代码中所有的标识符 N 替换成 20，而 #define NDEBUG 把 NDEBUG 定义为空，在预处理时把代码中所有的标识符 NDEBUG 替换成空。这样的宏定义主要是为了用 #ifdef 等预处理指示**测试它定义过没有**，而不是为了做替换，所以定义成**什么值都无所谓**，一般定义成空就足够了。

  - `-DNDEBUG`

    还有另一种办法，不必修改源文件，在编译命令行加上选项 -DNDEBUG 就相当于在源文件开头定义了 NDEBUG 宏。

    宏定义和预处理到第 21 章预处理再详细解释，在第 4 节「其它预处理特性」将给出 assert.h 一种实现。
