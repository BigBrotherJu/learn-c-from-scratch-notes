# 14. 计算机中数的表示

## 14.1 为什么计算机用二进制计数

- 十进制

  人类的计数方式通常是「逢十进一」，称为十进制（Decimal），大概因为人有十个手指，所以十进制是最自然的计数方式，很多民族的语言文字中都有十个数字，而阿拉伯数字 0~9是目前最广泛采用的。

- 二进制

  计算机是用数字电路搭成的，数字电路中只有 1 和 0 两种状态，或者可以说计算机只有两个手指，所以对计算机来说二进制（Binary）是最自然的计数方式。

  根据「逢二进一」的原则，十进制的 1、2、3、4 分别对应二进制的 1、10、11、100。

  - Bit

    二进制的一位数字称为一个位（Bit），三个 bit 能够表示的最大的二进制数是 111，也就是十进制的 7。

- 数字大小没有变

  不管用哪种计数方式，数的大小并没有变，十进制的 1+1 等于2，二进制的 1+1 等于 10，二进制的 10 和十进制的 2 大小是相等的。

- 一位全加器

  事实上，计算机采用如下的逻辑电路计算两个bit的加法。

  图的上半部分（出自Wikipedia）的电路称为一位全加器（1-bit Full Adder），图的下半部分是一些逻辑电路符号的图例。

  - 图例：门电路、导线、黑点

    我们首先解释这些图例，逻辑电路由门电路（Gate）和导线（Wire）组成。

    同一条导线上在某一时刻的电压值只能是高和低两种状态之一，分别用0和1表示。

    如果两条导线短接在一起则它们的电压值相同，在接点处画一个黑点，如果接点处没有画黑点则表示这两条线并没有短接在一起，只是在画图时无法避免交叉。

    导线的电压值进入门电路的输入端，经过逻辑运算后在门电路的输出端输出运算结果的电压值，任何复杂的加减乘除运算都可以分解成简单的逻辑运算。

    AND、OR和NOT运算在第 3 节「布尔代数」中讲过了，这三种逻辑运算分别用与门、或门和反相器（Inverter）实现。

    另外几种逻辑运算在这里补充一下。异或（XOR，eXclusive OR）运算两个操作数相同则结果为0，两个操作数不同则结果为1。与非（NAND）和或非（NOR）运算就是在与、或运算的基础上取反。

    如果把与门、或门和反相器组合来实现NAND和NOR运算，则电路过于复杂了，因此逻辑电路中通常有专用的与非门和或非门。

- 多位加法器

  如果把很多个一位全加器串接起来，就成了多位加法器。

  图中的一位全加器用方框表示，上一级全加器的 Cout 连接到下一级全加器的 Cin，让进位像涟漪一样一级一级传开，所以叫做 Ripple Carry Adder，这样就可以把两个 4 bit 二进制数 A3A2A1A0 和 B3B2B1B0 加起来了。

  在这里介绍 Ripple Carry Adder 只是为了让读者理解计算机是如何通过逻辑运算来做算术运算的，实际上这种加法器效率很低，只能加完了一位再加下一位，更实用、更复杂的加法器可以多个位一起计算，有兴趣的读者可参考 数字逻辑基础。

## 14.2 不同进制之间的换算

- 最高位和最低位

  对于 (A3A2A1A0)2 这样一个二进制数，最左边的 A3 位称为最高位（MSB，Most Significant Bit），最右边的 A0 位称为最低位（LSB，Least Significant Bit）。

  以后我们遵循这样的惯例：LSB 称为第 0 位而不是第 1 位，所以如果一个数是 32 位的，则 MSB 是第 31 位。

- 二进制到十进制

- 十进制到二进制：除二反序取余法

  13=1×2<sup>3</sup>+1×2<sup>2</sup>+0×2<sup>1</sup>+1×2<sup>0</sup>

  所以13换算成二进制应该是(1101)<sub>2</sub>。问题是怎么把13分解成等号右边的形式呢？注意到等号右边可以写成

  13=((((0×2+1<sub>3</sub>)×2+1<sub>2</sub>)×2+0<sub>1</sub>)×2+1<sub>0</sub>

  我们将13反复除以2取余数就可以提取出上式中的1101四个数字。

- 八进制

- 十六进制

## 14.3 整数的加减运算

我们已经了解了计算机中正整数如何表示，加法如何计算，那么负数如何表示，减法又如何计算呢？

本节讨论这些问题。为了书写方便，本节举的例子都用 8 个 bit 表示一个数。

### 14.3.1 Sign and Magnitude 表示法

要用 8 个 bit 表示正数和负数，一种简单的想法是把最高位规定为符号位（Sign Bit），0 表示正 1 表示负，剩下的 7 位表示绝对值的大小，这称为 Sign and Magnitude 表示法。

- 取值范围

  这样用 8 个 bit 表示整数的取值范围即 -127~127。

- 加法

  采用这种表示法，计算机做加法运算需要处理以下逻辑：

  如果两数符号位相同，就把它们的低 7 位相加，符号位不变。如果低 7 位相加时在最高位产生进位，说明结果的绝对值大于 127，超出 7 位所能表示的数值范围，这称为溢出（Overflow），这时通常把计算机中的一个标志位置 1 表示当前运算产生了溢出。

  有时候会进一步细分，把正整数溢出称为上溢（Overflow），负整数溢出称为下溢（Underflow），详见 strtol(3)。

  如果两数符号位不同，首先比较它们的低 7 位谁大，然后用大数减小数，结果的符号位和大数相同。

- 减法

  那么减法如何计算呢？由于我们规定了负数的表示，可以把减法转换成加法来计算，要计算 a-b，可以先把 b 变号然后和 a 相加，相当于计算 a+(-b)。

  但如果两个加数的符号位不同就要用大数的绝对值减小数的绝对值，这一步**减法计算仍然是免不了**的。

  我们知道加法要进位，减法要借位，计算过程是不同的，所以除了要有第 1 节「为什么计算机用二进制计数」提到的加法器电路之外，还要另外有一套减法器电路。

- 缺点

  如果采用 Sign and Magnitude 表示法，计算机做加减运算需要处理很多逻辑：比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数……这是非常低效率的。

  还有一个缺点是 0 的表示不唯一，既可以表示成 10000000 也可以表示成 00000000，这进一步增加了逻辑的复杂性，所以我们迫切需要重新设计整数的表示方法使计算过程更简单。

### 14.3.2 1's Complement表示法

本节介绍一种二进制补码表示法，为了便于理解，我们先看一个十进制的例子。

- 9's Complement 表示法

- 1's Complement 表示法

  - 两个例子

    我们观察一个被减数大于减数的例子，运算时做的变换尽量使用加法。

    ```
    00010000 - 00000100 = 
    00010000 + (11111111 - 00000100) - 100000000 + 1
    ```

    我们可以看到 `00010000 + (11111111 - 00000100)` 绝对要进位，因为被减数大于减数。而这个进的位正好可以用 `100000000` 减掉。最后面还有个 `+ 1`，我们就可以说把这个进位放到最低位上。

    总结起来，被减数如果大于减数，那么我们可以给减数做 `11111111 - 减数` 这样的变换。这个变换同样可以通过对减数每一位取反得到。变换好了以后，被减数和减数的变换相加，然后在最低位加 1 就能得到结果。可以看到，每一步都没有用到减法。

    现在我们试试被减数小于减数的例子。我们同样给减数进行上面的变换，看看能得到什么。

    ```
    00000100 - 00001000 =
    00000100 + (11111111 - 00001000) - 100000000 + 1 = 结果

    00000100 + (11111111 - 00001000) = 11111111 + 结果
    ```

    我们知道，结果肯定是负数。而 `11111111 + 结果` 就是上面提到的变换。

    所以，在被减数小于减数的例子中，我们也可以对减数进行变换。被减数和减数的变换相加以后就是结果的变换。

  - 变换

    我们可以看到上面提到的这个变换非常有用。我们给它一个名字，把它叫做「对某数取 1 的补码」。

    因为对某数取 1 的补码同样可以通过对该数绝对值每位取反得到，所以 1 的补码也叫反码。

  - 新的表示法：负数用 1 的补码表示，正数不变

    所以我们得到结论，遇到负数时，负数要用 1 的补码表示，然后把减法转换成加法，计算结果最高位如果有进位，则要加回到最低位上。

    结果中如果出现负数，同样是用 1 的补码表示。

    正数则是正常表示。

  - 取值范围

    我们限定二进制数是八位的，那么 -1 在新的表示法下就是 1111 1110，-0 就是 1111 1111。-127 是 1000 0000，+127 是 0111 1111，而 -128 是 0111 1111，+128 是 1000 0000。可以看到，产生了重复。所以八位二进制数用这种表示法取值范围是 -127～+127，而且 0 有两种表示方法。

  - 另外两种情况

    上面我们讨论了被减数大于减数以及被减数小于减数这两种情况。两个数的加减还剩下正数加正数和负数加负数两种情况。正数加正数没什么好讨论的，下面先看看负数加负数。

    ```
    - 00001000 - 00000100 = 结果
    (11111111 - 00001000) + (11111111 - 00000100) = 11111111 + 结果 + 100000000 - 1
    (11111111 - 00001000) + (11111111 - 00000100) - 100000000 + 1 = 11111111 + 结果
    ```

    如上面所说，负数要用 1 的补码表示。`(11111111 - 00001000) + (11111111 - 00000100)` 绝对会进位，不管减数和被减数是多少。要进位的话，减数的绝对值和被减数的绝对值加起来要小于等于 1111 1110，即 254，而负数最小是 -127，满足条件。

    我们可以把 `(11111111 - 00001000) + (11111111 - 00000100)` 的进位加到最后一位，这个技巧上面也用过。即加法过程中最高位如果有进位，则回到最低位上。

    总结起来，即两个负数相加时，取两个负数 1 的补码，把两个补码加起来，把进位放在最低位，得到的结果即是结果的补码。

  - 溢出没有讨论

  - 1's Complement 表示法与 Sign and Magnitude 表示法

    1's Complement 表示法相对于 Sign and Magnitude 表示法的优势是非常明显的：不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，计算逻辑更简单，甚至连减法器电路都省了，只要有一套加法器电路，再有一套把每个 bit 取反的电路，就可以做加法和减法运算。

    如果 8 个 bit 采用 1's Complement 表示法，负数的取值范围是从 10000000 到 11111111（-127~0），正数是从 00000000 到 01111111（0~127），仍然可以根据最高位判断一个数是正是负。

    美中不足的是 0 的表示仍然不唯一，既可以表示成 11111111 也可以表示成 00000000，为了解决这最后一个问题，我们引入 2's Complement 表示法。

### 14.3.3 2's Complement 表示法

- 解决 1's Complement 缺点

  1's Complement 表示法中 0 有两种表示。我们尝试更改表示法，让 0 只有一种表示。我们可以变换完负数以后再加一个 1，这样 -0 变换完的 11111111 就变成 00000000 了。0 就只有一种表示了。

- 取值范围

  -1 是 1111 1111，-127 是 1000 0001，-128 是 1000 0000，-129 是 0111 1111。

  +1 是 0000 0001，+127 是 0111 1111，+128 是 1000 0000。

  为了保证负数最高位是 1，取值范围为 -128～+127。

- 三种情况

  - 被减数大于减数

    我们观察一个被减数大于减数的例子，运算时尽量使用 2's Complement。

    ```
    00010000 - 00000100 = 
    00010000 + (11111111 - 00000100 + 1) - 100000000 + 1 - 1
    ```

    我们可以看到 `00010000 + (11111111 - 00000100 + 1)` 绝对要进位，因为被减数大于减数。而这个进的位正好可以用 `100000000` 减掉。最后面还有个 `+ 1` 用 `-1` 抵消掉。我们可以说忽略这个进位。

    总结起来，被减数如果大于减数，那么我们可以给减数做 `11111111 - 减数 + 1` 这样的变换。变换好了以后，被减数和减数的变换相加，进位忽略就可以得到结果。可以看到，每一步都没有用到减法。

  - 被减数等于减数

    ```
    00010000 - 00010000 = 
    00010000 + (11111111 - 00010000 + 1) - 100000000 + 1 - 1
    ```

    `00010000 + (11111111 - 00010000 + 1)` 也要进位，这个进位也是忽略。

  - 被减数小于减数

    现在我们试试被减数小于减数的例子。我们同样给减数进行上面的变换，看看能得到什么。

    ```
    00000100 - 00001000 =
    00000100 + (11111111 - 00001000 + 1) - 100000000 + 1 - 1 = 结果

    00000100 + (11111111 - 00001000 + 1) = 11111111 + 结果 + 1
    ```

    我们知道，结果肯定是负数。而 `11111111 + 结果 + 1` 就是上面提到的变换。

    所以，在被减数小于减数的例子中，我们也可以对减数进行变换。被减数和减数的变换相加以后就是结果的变换。

- 两种溢出情况

  8 个 bit 采用 2's Complement 表示法的取值范围是 -128~127，如果计算结果超出这个范围就会产生溢出。

  如果两个正数相加溢出，结果一定是负数；如果两个负数相加溢出，结果一定是正数；一正一负相加，无论结果是正是负都不可能溢出。

  ![如何判定溢出](image/如何判定溢出.png)

  从上图可以得出结论：在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。

- 表示法

  2's Complement 表示法规定：正数不变，负数先取反码再加 1。

  如果 8 个 bit 采用 2's Complement表示法，负数的取值范围是从 10000000 到 11111111（-128~-1），正数是从 00000000 到 01111111（0~127），也可以根据最高位判断一个数是正是负，并且 0 的表示是唯一的，目前绝大多数计算机都采用这种表示法。

- 为什么叫 2 的补码

  为什么称为「2 的补码」呢？

  因为对一位二进制数 b 取 2 的补码就是 1-b+1=10-b，相当于从 2 里面减去 b。

  类似地，要表示 -4 需要对 00000100 取补码，11111111-00000100+1=100000000-00000100，相当于从 2<sup>8</sup> 里面减去 4。

  2's Complement 表示法的计算规则有些不同：减法转换成加法，忽略计算结果最高位的进位，不必加回到最低位上去。请读者自己验证上一节提到的四种情况下这条规则都能算出正确结果。

### 有符号数和无符号数

- 有符号数

  前面几节我们用 8 个 bit 表示正数和负数，讲了三种表示法，每种表示法对应一种计算规则，这称为有符号数（Signed Number）；

  如果 8 个 bit 全部表示正数则取值范围是 0~255，这称为无符号数（Unsigned Number）。

- 计算机做加法时不区分有符号数和无符号数

  其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样。

- 进位标志、溢出标志、零标志、负数标志

  计算机的加法器在做完计算之后，根据最高位产生的进位设置**进位标志**，同时根据最高位和次高位产生的进位的异或设置**溢出标志**。

  至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。

  通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有 bit 都是零则设置**零标志**，如果计算结果的最高位是 1 则设置**负数标志**，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。

## 14.4 浮点数

- 科学计数法

  浮点数在计算机中的表示是基于科学计数法（Scientific Notation）的，我们知道 32767 这个数用科学计数法可以写成 3.2767×10<sup>4</sup>，3.2767称为尾数（Mantissa，或者叫 Significand），4 称为指数（Exponent）。

  浮点数在计算机中的表示与此类似，只不过基数（Radix）是 2 而不是 10。

- 简单浮点数模型

  下面我们用一个简单的模型来解释浮点数的基本概念。

  我们的模型由三部分组成：符号位、指数部分（表示 2 的多少次方）和尾数部分（小数点前面是 0，尾数部分只表示小数点后的数字）。

  ![一种浮点数格式](image/一种浮点数格式.png)

  如果要表示 17 这个数，我们知道 17=17.0×10<sup>0</sup>=0.17×10<sup>2</sup>，类似地，17=(10001)<sub>2</sub>×2<sup>0</sup>=(0.10001)<sub>2</sub>×2<sup>5</sup>，把尾数的有效数字全部移到小数点后，这样就可以表示为：`0 00101 10001000`。

  - 偏移指数

    如果我们要表示 0.25 就遇到新的困难了，因为 0.25=1×2<sup>-2</sup>=(0.1)<sub>2</sub>×2<sup>-1</sup>，而我们的模型中指数部分没有规定如何表示负数。我们可以在指数部分**规定一个符号位**，然而更广泛采用的办法是使用偏移的指数（Biased Exponent）。规定一个偏移值，比如 16，实际的指数要加上这个偏移值再填写到指数部分，这样比 16 大的就表示正指数，比 16 小的就表示负指数。要表示 0.25，指数部分应该填 16-1=15：`0 01111 10000000`。

  - 正规化

    现在还有一个问题需要解决：每个浮点数的表示都不唯一，例如 17=(0.10001)<sub>2</sub>×2<sup>5</sup>=(0.010001)<sub>2</sub>×2<sup>6</sup>，这样给计算机处理增加了复杂性。

    为了解决这个问题，我们规定尾数部分的最高位必须是 1，也就是说尾数必须以 0.1 开头，对指数做相应的调整，这称为正规化（Normalize）。

    由于尾数部分的最高位必须是 1，这个 1 就不必保存了，可以节省出一位来用于提高精度，我们说最高位的 1是隐含的（Implied）。

    这样 17 就只有一种表示方法了，指数部分应该是 16+5=21=(10101)<sub>2</sub>，尾数部分去掉最高位的 1 是 0001：`0 10101 00010000`。

- 两个浮点数进行计算可能会出现精度损失

  两个浮点数相加，首先把小数点对齐然后相加：

  ![浮点数相加](image/浮点数相加.png)

  由于浮点数表示的精度有限，计算结果末尾的 10 两位被舍去了。

  做浮点运算时要注意精度损失（Significance Loss）问题，有时计算顺序不同也会导致不同的结果，比如 11.0010000+0.00000001+0.00000001=11.0010000+0.00000001=11.0010000，后面加的两个很小的数全被舍去了，没有对计算结果产生任何影响，但如果调一下计算顺序它们就能影响到计算结果了，0.00000001+0.00000001+11.0010000=0.00000010+11.0010000=11.0010001。

  再比如 128.25=(10000000.01)<sub>2</sub>，需要 10 个有效位，而我们的模型中尾数部分是 8 位，算上隐含的最高位 1 一共有 9 个有效位，那么 128.25 的浮点数表示只能舍去末尾的 1，表示成(10000000.0)<sub>2</sub>，其实跟 128 相等了。

  在第 2 节「if/else 语句」讲过浮点数不能做精确比较，现在读者应该知道为什么不能精确比较了。

- 溢出

  整数运算会产生溢出，浮点运算也会产生溢出，浮点运算的溢出也分上溢和下溢两种，但和整数运算的定义不同。

  假设整数采用 8 位 2's Complement 表示法，取值范围是 -128~127，如果计算结果是 -130 则称为下溢，计算结果是 130 则称为上溢。

  假设按本节介绍的浮点数表示法，取值范围是-(0.111111111)<sub>2</sub>×2<sup>15</sup>~(0.111111111)<sub>2</sub>×2<sup>15</sup>，如果计算结果超出这个范围则称为上溢；如果计算结果未超出这个范围但绝对值太小了，在-(0.1)<sub>2</sub>×2<sup>-16</sup>~(0.1)<sub>2</sub>×2<sup>-16</sup>之间，那么也同样无法表示，称为下溢。

- IEEE 754

  浮点数是一个相当复杂的话题，不同平台的浮点数表示和浮点运算也有较大差异，本节只是通过这个简单的模型介绍一些基本概念而不深入讨论，理解了这些基本概念有助于你理解浮点数标准，目前业界广泛采用的符点数标准是由 IEEE（Institute of Electrical and Electronics Engineers）制定的 IEEE 754。

- 用 0 初始化表示所有 bit 是 0

  最后讨论一个细节问题。

  我们知道，定义全局变量时如果没有 Initializer 就用 0 初始化，定义数组时如果 Initializer 中提供的元素不够那么剩下的元素也用 0 初始化。例如：

  ```
  int i;
  double d;
  double a[10] = { 1.0 };
  ```

  「用 0 初始化」的意思是变量 i、变量 d和数组元素 a[1]~a[9] 的所有字节都用 0 填充，或者说所有 bit 都是 0。

  - 一个整数的所有bit是0都表示0值

    无论是用 Sign and Magnitude 表示法、1's Complement 表示法还是 2's Complement 表示法，一个整数的所有 bit 是 0 都表示 0 值。

  - 一个浮点数的所有 bit 都是 0

    但一个浮点数的所有 bit 是 0 一定表示 0 值吗？严格来说不一定，某种平台可能会规定一个浮点数的所有 bit 是 0 并不表示 0 值，但 C99 Rationale 第 6.7.8 节的条款 25 提到：As far as the committee knows, all machines treat all bits zero as a representation of floating-point zero. But, all bits zero might not be the canonical representation of zero.

    因此在绝大多数平台上，一个浮点数的所有 bit 是 0 就表示 0 值。
