# 1. 程序的基本概念

## 1.1 程序和编程语言

### 指令和语句

- 指令

  程序由一系列指令（Instruction）组成，指令是指示计算机做某种运算的命令，通常包括以下几类：

  - 输入（Input）

    从键盘、文件或者其他设备获取数据。

  - 输出（Output）

    把数据显示到屏幕，或者存入一个文件，或者发送到其他设备。

  - 基本运算

    执行最基本的数学运算（加减乘除）和数据存取。

  - 测试和分支

    测试某个条件，然后根据不同的测试结果执行不同的后续指令。

  - 循环

    重复执行一系列<span class="thoughts">指令</span>。

  机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。

  不同的计算机体系结构有不同的指令集（Instruction Set)，可以识别的机器指令格式是不同的。

- 语句

  而C、C++、Java、Python等属于高级语言，用语句（Statement）编写程序。

  3GL 的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系。

- 指令和语句的关系

  语句是计算机指令的抽象表示。

  程序由语句或指令组成，计算机只能执行低级语言中的指令（汇编语言的指令要先转成机器码才能执行），高级语言要执行就必须先翻译成低级语言，翻译的方法有两种——编译和解释。

  - 编译

    C语言的语句和低级语言的指令之间不是简单的一一对应关系，一条a=b+1;语句要翻译成三条汇编或机器指令，这个过程称为编译（Compile），由编译器（Compiler）来完成，

  - 解释

    /bin/sh称为解释器（Interpreter），它把脚本中的每一行当做一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行。

    如果把脚本中的这三行当做三条命令直接敲到Shell提示符下，也能得到同样的结果。

  - 编译和解释结合

    还有很多编程语言采用编译和解释相结合的方式执行，这种方式相当流行，Java、Python、Perl 等编程语言都采用这种方式。

    以 Python 为例，程序员写的源代码 `.py` 文件首先被编译成 `.pyc` 文件，称为字节码（Byte Code），然后字节码被 Python 虚拟机解释执行。字节码是 Python 虚拟机的指令而非机器指令，所以它是平台无关的，如果把字节码文件从一种平台拷贝到另一种平台上，只要另一种平台也安装了 Python 虚拟机，就能运行这个字节码文件。

## 1.2 自然语言和形式语言

### 自然语言和形式语言

自然语言（Natural Language）就是人类讲的语言，比如汉语、英语和法语。这类语言不是人为设计（虽然有人试图强加一些规则）而是自然进化的。

形式语言（Formal Language）是为了特定应用而人为设计的语言。例如数学家用的数字和运算符号、化学家用的分子式等。编程语言也是一种形式语言，是专门设计用来表达**计算过程**的形式语言。

### Syntax

- Syntax: Tokens and structures, lexical rules and grammar rules

  形式语言有严格的语法（Syntax）规则，例如，3+3=6 是一个语法正确的数学等式，而 3=+6$ 则不是，H<sub>2</sub>O 是一个正确的分子式，而 <sub>2</sub>Zz 则不是。

  语法规则是由符号（Token）和结构（Structure）的规则所组成的。

- Tokens

  Token 的概念相当于自然语言中的单词和标点、数学式中的数和运算符、化学分子式中的元素名和数字，例如 3=+6$ 的问题之一在于 $ 不是一个合法的数也不是一个事先定义好的运算符，而 <sub>2</sub>Zz 的问题之一在于没有一种元素的缩写是 Zz。

- 结构

  结构是指 Token 的排列方式，3=+6$ 还有一个结构上的错误，虽然加号和等号都是合法的运算符，但是不能在等号之后紧跟加号，而 <sub>2</sub>Zz 的另一个问题在于分子式中必须把下标写在化学元素名称之后而不是前面。

- Lexical 规则和 Grammar 规则

  关于 Token 的规则称为词法（Lexical）规则，而关于结构的规则称为语法（Grammar）规则。

- 区别 Syntax 和 Grammar

  很不幸，Syntax 和 Grammar 通常都翻译成「语法」，这让初学者非常混乱。

  Syntax 的含义其实包含了 Lexical 和 Grammar 的规则，还包含一部分语义的规则（例如在 C 程序中变量应先声明后使用）。即使在英文的文献中 Syntax 和 Grammar 也经常混用，在有些文献中 Syntax 的含义不包括 Lexical 规则，只要注意上下文就不会误解。

  另外，本书在翻译容易引起混淆的时候通常直接用英文名称，例如 Token 没有十分好的翻译，直接用英文名称。

### Parsing and semantics

当阅读一个自然语言的句子或者一种形式语言的语句时，你不仅要搞清楚每个词（**Token**）是什么意思，而且必须搞清楚整个句子的**结构**是什么样的（在自然语言中你只是没有意识到，但确实这样做了，尤其是在读外语时你肯定也意识到了）。

这个分析句子结构的过程称为解析（Parse）。

例如，当你听到「The other shoe fell.」这个句子时，你理解 the other shoe 是主语而 fell 是谓语动词，一旦解析完成，你就搞懂了句子的意思。

如果知道 shoe 是什么东西，fall 意味着什么，这句话是在什么上下文（Context）中说的，你还能理解这个句子主要暗示的内容，这些属于语义（Semantic）的范畴。

## 1.3 程序的调试

### Bug 的分类

- 编译时错误

  编译器只能翻译**语法正确**的程序，否则将导致编译失败，无法生成可执行文件。

  对于自然语言来说，一点**语法错误**不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，哪怕只有一个很小的语法错误，编译器也会输出一条错误提示信息然后罢工，你就得不到想要的结果。

  虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。

  在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯类似的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。

- 运行时错误

  编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。

  对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。

  - 区分编译时和运行时

    读者在以后的学习中要时刻注意区分编译时和运行时（Run-time）这两个概念，不仅在调试时需要区分这两个概念，在学习C语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。

- 逻辑错误和语义错误

  第三类错误是逻辑错误和语义错误。

  如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。

## 1.4 第一个程序

### 初步接触 gcc

通常一本教编程的书中第一个例子都是打印 「Hello, World.」，这个传统源自参考文献 [3]，用 C 语言写这个程序可以这样写：

``` c
#include <stdio.h>

/* main: generate some simple output */

int main(void)
{
    printf("Hello, world.\n");
    return 0;
}
```

在 Linux 平台上，将这个程序保存成主目录下的 `main.c`，然后编译运行：

``` console
$ gcc main.c
$ ./a.out
Hello, world.
```

- `a.out`

  gcc 是 Linux 平台的 C 编译器，编译后在当前目录下生成可执行文件 `a.out`，直接在命令行输入这个可执行文件的路径就可以执行它。

  `a.out` 是「Assembler Output」的缩写，实际上一个 C 程序要先被编译器翻译成汇编程序，再被汇编器翻译成机器指令，最后还要经过链接器的处理才能成为可执行文件，详见第 18.2 节。

- `-o` 参数

  如果不想把文件名叫 `a.out`，可以用 gcc 的 `-o` 参数自己指定文件名：

  ``` console
  $ gcc main.c -o main
  $ ./main
  Hello, world.
  ```

### Boilerplate

每个程序按惯例必须要写的部分（Boilerplate）。

注意语句的末尾以 ; 号（Semicolon）结束，下一条语句 `return 0;` 也是如此。

C 语言用 {} 括号（Brace 或 Curly Brace）把语法结构分成组，在上面的程序中 `printf` 和 `return` 语句套在 `main` 的 {} 括号中，表示它们属于 `main` 的定义之中。

### Errors and warnings

- Errors

  编译器对于语法错误是毫不留情的，如果你的程序有一点拼写错误，例如第一行写成了 `stdoi.h`，在编译时会得到错误提示：

  ``` console
  main.c:1:19: error: stdoi.h: No such file or directory
  ...
  ```

- Warnings

  有些时候编译器的提示信息不是 error 而是 warning，例如把上例中的 `printf("Hello, world.\n");` 改成 `printf(1);` 然后编译运行：

  ``` console
  $ gcc main.c
  main.c: In function 'main':
  main.c:7:warning: passing argument 1 of 'printf' makes pointer from integer without a cast
  ...
  $ ./a.out
  Segmentation fault
  ```

  这个警告信息是说类型不匹配，但勉强还能配得上。警告信息不是致命错误，编译仍然可以继续，如果整个编译过程只有警告信息而没有错误信息，仍然可以生成可执行文件。

  但是，警告信息也是不容忽视的。出警告信息说明你的程序写得不够规范，可能有 Bug，虽然能编译生成可执行文件，但程序的运行结果往往是不正确的，例如上面的程序运行时出了一个段错误，这属于**运行时错误**。

  各种警告信息的严重程度不同，像上面这种警告几乎一定表明程序中有 Bug，而另外一些警告只表明程序写得不够规范，一般还是能正确运行的，有些不重要的警告信息 gcc 默认是不提示的，但这些警告信息也有可能表明程序中有 Bug。

- gcc `-Wall` 选项

  一个好的习惯是打开 gcc 的 `-Wall` 选项，让 gcc 提示所有的警告信息，不管是严重的还是不严重的，然后把这些问题从代码中全部消灭。

  虽然本书的命令行为了突出重点通常省略 `-Wall` 选项，但是强烈建议你写每一个编译命令时都加上 `-Wall` 选项。
