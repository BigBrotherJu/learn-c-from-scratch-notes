# 5. 深入理解函数

## 5.1 return 语句

### return 语句的作用

之前我们一直在main函数中使用return语句，现在是时候全面深入地学习一下了。

- 在有返回值的函数中，return 提供函数返回值并结束函数

  在有返回值的函数中，return语句的作用是提供整个函数的返回值，并结束当前函数返回到调用它的地方。

- 在没有返回值的函数中，return 结束函数

  在没有返回值的函数中也可以使用return语句，例如当检查到一个错误时提前结束当前函数的执行并返回。

### return 语句中的括号

有些人喜欢写成return(1);这种形式也可以，表达式外面套括号表示改变运算符优先级，在这里不起任何作用。

### 谓词

返回布尔值的函数是一类非常有用的函数，在程序中通常充当控制表达式，函数名通常带有is或if等表示判断的词，这类函数也叫做谓词（Predicate）。

### 函数返回值的理解

<span class="thoughts">

``` c
int is_even(int x)
{
    return !(x % 2);
}

int main(void)
{
    int i = 19;
    if (is_even(i)) {
        /* do something */
    } else {
        /* do some other thing */
    }
}
```

</span>

函数的返回值应该这样理解：函数返回一个值相当于定义一个和返回值类型相同的临时变量并用return后面的表达式来初始化。

例如上面的函数调用相当于这样的过程：

``` c
int tmp = !(x % 2);
函数退出，局部变量 x 的存储空间释放;
if (tmp) { /* 临时变量用完就释放 */
    /* do something */
} else {
    /* do some other thing */
}
```

当if语句对函数的返回值做判断时，函数已经退出，局部变量x已经释放，所以不可能在这时候才计算表达式!(x % 2)的值，表达式的值必然是事先计算好了保存在一个没有名字的临时变量里的，然后函数退出，局部变量释放，if语句对这个临时变量的值做判断。

- 函数调用表达式不能做左值

  注意，虽然函数的返回值可以看作是一个临时变量，但我们只是读一下它的值，**读完值就释放它**，而**不能往它里面存新的值**，换句话说，函数的返回值不是左值，或者说函数调用表达式不能做左值，因此下面的赋值语句是非法的：

  ``` c
  is_even(20) = 1;
  ```

- 返回值也是按值传递的

  在第3.3节中讲过，C语言的传参规则是Call by Value，按值传递，现在我们知道返回值也是按值传递的，即便返回语句写成return x;，返回的也是**变量x的值**，而**非变量x本身**，因为变量x马上就要被释放了。

### 代码路径和 dead code

在写带有return语句的函数时要小心检查所有的代码路径（Code Path）。

有些代码路径在任何条件下都执行不到，这称为Dead Code。

- 笔误导致的 dead code

  例如把&&和||运算符记混了（据我了解初学者犯这个低级错误的不在少数），写出如下代码：

  ``` c
  void foo(int x, int y)
  {
      if (x >= 0 || y >= 0) {
          printf("both x and y are positive.\n");
          return;
      } else if (x < 0 || y < 0) {
          printf("both x and y are negative.\n");
          return;
      }
      printf("x has a different sign from y.\n");
  }
  ```

  最后一行printf永远都没机会被执行到，是一行Dead Code。

- dead code 属于逻辑错误和语义错误

  有Dead Code就一定有Bug，你写的每一行代码都是想让程序在某种情况下去执行的，你不可能故意写出一行永远不会被执行的代码，如果程序在任何情况下都不会去执行它，说明跟你预想的不一样，要么是你对所有可能的情况分析得不正确，要么就是像上例这样的笔误，这些属于**逻辑错误和语义错误**。

- 对所有可能的情况分析不全面不正确导致的 dead code

  <span class = "thoughts">像上面说的~~还有一些时候~~</span>，对程序中所有可能的情况分析得不够全面将导致漏掉一些代码路径，例如：

  ``` c
  int absolute_value(int x)
  {
      if (x < 0) {
          return -x;
      } else if (x > 0) {
          return x;
      }
  }
  ```

  - 某种情况下如果没有返回值，则返回不定值

    这个函数被定义为返回int，就应该在任何情况下都返回int，但是上面这个程序在x==0时安静地退出函数，什么也不返回，C标准对于这种情况会返回什么结果是未定义的，通常**返回不确定的值**，等学到第18.1节你就知道为什么了。

### 正负号和加减号

另外注意这个例子中把-号当负号用而不是当减号用，事实上+号也可以这么用。

正负号是单目运算符，而加减号是双目运算符，正负号的优先级和逻辑非运算符相同，比加减的优先级要高。

### 编译器提示和 dead code

以上两段代码都不会产生编译错误，编译器只做语法检查和最简单的语义检查，而不检查程序的逻辑。

有的代码路径没有返回值的问题编译器是可以检查出来的，如果编译时加-Wall选项会报警告。

虽然到现在为止你见到了各种各样的编译器错误提示，也许你已经十分讨厌编译器报错了，但很快你就会认识到，如果程序中有错误编译器还不报错，那一定比报错更糟糕。

## 5.2 增量式开发

### 增量式开发

目前为止你看到了很多示例代码，也在它们的基础上做了很多改动并在这个过程中巩固所学的知识。

但是如果从头开始编写一个程序解决某个问题，应该按什么步骤来写呢？本节提出一种增量式（Incremental）开发的思路，很适合初学者。

这样的增量式开发非常适合初学者，每写一行代码都编译运行，确保没问题了再写下一行，一方面在写代码时更有信心，另一方面也方便了调试：总是有一个先前的正确版本做参照，改动之后如果出了问题，几乎可以肯定就是刚才改的那行代码出的问题，这样就避免了必须从很多行代码中查找分析到底是哪一行出的问题。

在这个过程中printf功不可没，你怀疑哪一行代码有问题，就插一个printf进去看看中间的计算结果，任何错误都可以通过这个办法找出来。以后我们会介绍程序调试工具gdb，它提供了更强大的调试功能帮你分析更隐蔽的错误。但即使有了gdb，printf这个最原始的办法仍然是最直接、最有效的。

随着编程经验越来越丰富，你可能每次写若干行代码再一起测试，而不是像现在这样每写一行就测试一次，但不管怎么样，增量式开发的思路是很有用的，它可以帮你节省大量的调试时间，不管你有多强，都不应该一口气写完整个程序再编译运行，那几乎是一定会有Bug的，到那时候再找Bug就难了。

### 手脚架

一旦验证无误，函数里的这句打印就可以撤掉了，像这种打印语句，以及我们用来测试的main函数，都起到了类似脚手架（Scaffold）的作用：在盖房子时很有用，但它不是房子的一部分，房子盖好之后就可以拆掉了。

房子盖好之后可能还需要维修、加盖、翻新，又要再加上脚手架，这很麻烦，要是当初不用拆就好了，可是不拆不行，不拆多难看啊。写代码却可以有一个更高明的解决办法：把Scaffolding的代码**注释掉**。

这样如果以后出了新的Bug又需要跟踪调试时，还可以把这句重新加进代码中使用。

### 复用代码，避免重复写代码

维护重复的代码是非常容易出错的，在任何时候都要尽量避免。

因此，尽可能复用（Reuse）以前写的代码，避免写重复的代码。

封装就是为了复用，把解决各种小问题的代码封装成函数，在解决第一个大问题时可以用这些函数，在解决第二个大问题时可以复用这些函数。

### 函数的分层设计

解决问题的过程是把大问题分解成小问题，小问题再分解成更小的问题，这个过程在代码中体现为函数的分层设计（Stratify）。

distance和area是两个底层函数，解决一些很小的问题，而area_point是一个上层函数，上层函数通过调用底层函数来解决更大的问题，底层和上层函数都可以被更上一层的函数调用，最终所有的函数都直接或间接地被main函数调用。

## 5.3 递归

### 什么是递归

如果定义一个概念需要用到这个概念本身，我们称它的定义是递归的（Recursive）。

- n 的阶乘就是递归定义的

  数学上确实有很多概念是用它自己来定义的，比如n的阶乘（Factorial）是这样定义的：n的阶乘等于n乘以n-1的阶乘。

  如果这样就算定义完了，恐怕跟上面那个词条有异曲同工之妙了：n-1的阶乘是什么？是n-1乘以n-2的阶乘。那n-2的阶乘又是什么？这样下去永远也没完。

  因此需要定义一个最关键的基础条件（Base Case）：0的阶乘等于1。

  因此，3!=3×2!，2!=2×1!，1!=1×0!=1×1=1，正因为有了Base Case，才不会永远没完地数下去，知道了1!=1我们再反过来算回去，2!=2×1!=2×1=2，3!=3×2!=3×2=6。

### 递归函数

- 计算 n 阶乘的递归函数

  下面用程序来完成这一计算过程，我们要写一个计算阶乘的函数factorial，先把Base Case这种最简单的情况写进去：

  ``` c
  int factorial(int n)
  {
      if (n == 0)
          return 1;
  }
  ```

  如果参数n不是0应该return什么呢？根据定义，应该return n*factorial(n-1);，为了下面的分析方便，我们引入几个临时变量把这个语句拆分一下：

  ``` c
  int factorial(int n)
  {
      if (n == 0)
          return 1;
      else {
          int recurse = factorial(n - 1);
          int result = n * recurse;
          return result;
      }
  }
  ```

- 自己直接或间接调用自己

  自己**直接或间接**调用自己的函数称为递归函数。

  这里的factorial是直接调用自己。

  有些时候函数A调用函数B，函数B又调用函数A，也就是函数A间接调用自己，这也是一种递归调用。

  如果你觉得迷惑，可以把factorial(n-1)这一步看成是在调用另一个函数——另一个有着相同函数名和相同代码的函数，调用它就是跳到它的代码里执行，然后再返回factorial(n-1)这个调用的下一步继续执行。

- 递归调用时每层函数的存储空间用栈保存

  我们看图5.2右侧存储空间的变化过程，随着函数调用的层层深入，存储空间的一端逐渐增长，然后随着函数调用的层层返回，存储空间的这一端又逐渐缩短，并且每次访问参数和局部变量时只能访问这一端的存储单元，而不能访问内部的存储单元，比如当factorial(2)的存储空间位于末端时，只能访问它的参数和局部变量，而不能访问factorial(3)和main()的参数和局部变量。

  具有这种性质的数据结构称为堆栈或**栈**（Stack），随着函数调用和返回而不断变化的这一端称为**栈顶**，每个函数调用的参数和局部变量的存储空间（图5.2中的每个小方框）称为一个**栈帧**（Stack Frame）。

  操作系统为程序的运行**预留了一块栈空间**，函数调用时就在这个栈空间里分配栈帧，函数返回时就释放栈帧。

- Leap of Faith

  事实上并不是每个函数调用都需要钻进去看的。

  我们在调用printf时没有钻进去看它是怎么打印的，我们只是相信它能打印，能正确完成它的工作，然后就继续写下面的代码了。

  在上一节中，我们写了distance和area函数，然后立刻测试证明了这两个函数是正确的，然后我们写area_point时调用了这两个函数，我们需要钻进distance和area函数中去走一趟才知道我们调用得是否正确吗？不需要，因为我们已经相信这两个函数能正确工作了，也就是相信把坐标传给distance它就能返回正确的距离，把半径传给area它就能返回正确的面积，因此调用它们去完成另外一件工作也应该是正确的。

  这种“相信”称为Leap of Faith，首先相信一些结论，然后再用它们去证明另外一些结论。

- 用 Leap of Faith 证明 factorial 函数正确

  在写factorial(n)的代码时写到这个地方：

  ``` c
  ...
  int recurse = factorial(n-1);
  int result = n * recurse;
  ...
  ```

  这时，如果我们相信factorial(n-1)是正确的，也就是相信传给它n-1它就能返回(n-1)!，那么recurse就是(n-1)!，那么result就是n*(n-1)!，也就是n!，这正是我们要返回的factorial(n)的结果。

  当然这有点奇怪：我们还没写完factorial这个函数，凭什么要相信factorial(n-1)是正确的？可Leap of Faith本身就是Leap（跳跃）的，不是吗？

  如果你相信你正在写的递归函数是正确的，并调用它，然后在此基础上写完这个递归函数，那么它就会是正确的，从而值得你相信它正确。

- 数学上严格证明 factorial 函数正确

  这么说好像有点儿玄，我们从数学上严格证明一下factorial函数的正确性。

  刚才说了，factorial(n)的正确性依赖于factorial(n-1)的正确性，只要后者正确，在后者的结果上乘个n返回这一步显然也没有疑问，那么我们的函数实现就是正确的。

  因此要证明factorial(n)的正确性就是要证明factorial(n-1)的正确性，同理，要证明factorial(n-1)的正确性就是要证明factorial(n-2)的正确性，依此类推下去，最后是：要证明factorial(1)的正确性就是要证明factorial(0)的正确性。

  而factorial(0)的正确性不依赖于别的函数调用，它就是程序中的一个小的分支return 1;，这个1是我们根据阶乘的定义写的，肯定是正确的，因此factorial(1)的实现是正确的，因此factorial(2)也正确，依此类推，最后factorial(n)也是正确的。

  其实这就是在中学时学的数学归纳法（Mathematical Induction），用数学归纳法来证明只需要证明两点：Base Case正确，递推关系正确。

- 漏掉 base case 会无穷递归

  写递归函数时一定要记得写Base Case，否则即使递推关系正确，整个函数也不正确。

  如果factorial函数漏掉了Base Case，那么这个函数就会永远调用下去，直到操作系统为程序预留的栈空间耗尽程序崩溃（段错误）为止，这称为无穷递归（Infinite recursion）。

### 目前学到的语法已经完备

- 目前学到的 C 语法子集是完备的

  到目前为止我们只学习了全部C语法的一个小的子集，但是现在应该告诉你：这个子集是**完备**的，它本身就可以作为一门编程语言了。

- 以后要学的 C 特性可以用目前学到的特性代替，不是必不可少的

  以后还要学习很多C语言特性，但全部都可以用已经学过的这些特性来代替。

  也就是说，以后要学的C语言特性会使代码写起来更加方便，但不是必不可少的。

- 目前学到的已经覆盖五种基本指令

  现在学的这些已经完全覆盖了第1.1节讲的五种基本指令了。

  - 递归和循环是等价的

    有的读者会说循环还没讲到呢，是的，循环在下一章才讲，但有一个重要的结论就是递归和循环是等价的，用循环能做的事用递归都能做，反之亦然。

  - 有的编程语言只有递归没有循环

    事实上有的编程语言（比如某些LISP实现）只有递归而没有循环。

- 为什么计算机有且只有五种基本指令

  计算机指令能做的所有事情就是数据存取、运算、测试和分支、循环（或递归），在计算机上运行高级语言写的程序最终也要翻译成指令，指令做不到的事情高级语言写的程序肯定也做不到，虽然高级语言有丰富的语法特性，但也只是比指令写起来更方便而已，能做的事情是一样多的。

  那么，为什么计算机要设计成这样？在设计时怎么想到计算机应该具备这几样功能，而不是**更多或更少的功能**？

  这些要归功于早期的计算机科学家，例如Alan Turing，他们在计算机还没有诞生的年代就从数学理论上为计算机的设计指明了方向。有兴趣的读者可以参考有关计算理论的教材，例如参考文献[10]。

### 递归的重要性

递归绝不只是为解决一些奇技淫巧的数学题而想出来的招，它是计算机的精髓所在，也是编程语言的精髓所在。

- 表达式是递归定义的

  我们在学习C的语法时已经看到很多递归定义了，例如在第3.1节讲过的语法规则中，“表达式”就是递归定义的：

  表达式 → 表达式(参数列表)

  参数列表 → 表达式, 表达式, ...

- 语句也是递归定义的

  再比如在第4.1节讲过的语法规则中，“语句”也是递归定义的：

  语句 → if (控制表达式) 语句

- 编译器解析程序时也用了递归

  可见编译器在解析我们写的程序时一定也用了大量的递归，有关编译器的实现原理可参考文献[11]。
