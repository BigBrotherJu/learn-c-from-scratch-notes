# 12. 栈与队列

<!-- 12.3 12.4 12.5 no highlight -->

## 12.1 数据结构的概念

- 数据结构是数据的组织方式

  数据结构（Data Structure）是数据的组织方式。

  程序中用到的数据都不是孤立的，而是有相互联系的，根据访问数据的需求不同，同样的数据可以有多种不同的组织方式。

  以前学过的复合类型也可以看作数据的组织方式，把同一类型的数据组织成数组，或者把描述同一对象的各成员组织成结构体。

- 数据的组织方式包含存储方式和访问方式

  数据的组织方式包含了存储方式和访问方式这两层意思，二者是紧密联系的。

  例如，数组的各元素是一个挨一个存储的，并且每个元素的大小相同，因此数组可以提供按下标访问的方式，结构体的各成员也是一个挨一个存储的，但是每个成员的大小不同，所以只能用.运算符加成员名来访问，而不能按下标访问。

- 数据的存储方式和访问方式决定了解决问题的算法

  本章主要介绍栈和队列这两种数据结构以及它们的应用。

  从本章的应用实例可以看出，一个问题中数据的存储方式和访问方式就决定了解决问题可以采用什么样的算法，要设计一个算法就要同时设计相应的数据结构来支持这种算法。

- 算法 + 数据结构 = 程序

  所以Pascal语言的设计者Niklaus Wirth提出：算法+数据结构=程序（详见参考文献[20]）。

## 12.2 堆栈

- 堆栈类似数组，但是只能用 push 和 pop 对栈顶进行访问

  在第5.3节中我们已经对堆栈这种数据结构有了初步认识。

  堆栈是一组元素的集合，类似于数组，不同之处在于，数组可以按下标随机访问，这次访问a[5]下次可以访问a[1]，但是堆栈的访问规则被限制为Push和Pop两种操作，Push（入栈或压栈）向栈顶添加元素，Pop（出栈或弹出）则取出当前栈顶的元素，也就是说，只能访问栈顶元素而不能访问栈中其他元素。

- 用堆栈实现倒序打印

  如果所有元素的类型相同，堆栈的存储也可以用数组来实现，访问操作可以通过函数接口提供。看以下的示例程序。

  ``` c
  #include <stdio.h>

  char stack[512];
  int top = 0;

  void push(char c)
  {
      stack[top++] = c;
  }

  char pop(void)
  {
      return stack[--top];
  }

  int is_empty(void)
  {
      return top == 0;
  }

  int main(void)
  {
      push('a');
      push('b');
      push('c');

      while (!is_empty())
          putchar(pop());
      putchar('\n');

      return 0;
  }
  ```

  运行结果是cba。

  - 栈顶指针

    数组stack是堆栈的存储空间，变量top总是保存数组中栈顶的下一个元素的下标，我们说“top总是指向栈顶的下一个元素”，或者把top叫做栈顶指针（Pointer）。

  - Class invariant

    在第11.2节中介绍了Loop Invariant的概念，可以用它检验循环的正确性，这里的“top总是指向栈顶的下一个元素”其实也是一种Invariant，Push和Pop操作总是维持这个条件不变，这种Invariant描述的对象是一个数据结构而不是一个循环，在DbC中称为Class Invariant。

  - putchar 函数

    putchar函数的作用是把一个字符打印到屏幕上，和printf的%c作用相同。

  - 越界检查

    布尔函数is_empty的作用是防止Pop操作访问越界。这里我们预留了足够大的栈空间（512个元素），其实严格来说Push操作之前也应该检查栈是否满了。

- LIFO

  在main函数中，入栈的顺序是'a'、'b'、'c'，而出栈打印的顺序却是'c'、'b'、'a'，最后入栈的'c'最早出来，因此堆栈这种数据结构的特点可以概括为LIFO（Last In First Out，后进先出）。

- 用函数调用针栈实现后进先出

  我们也可以写一个递归函数做倒序打印，利用函数调用的栈帧实现后进先出。

## 12.3 深度优先搜索

- 深度优先搜索

- 回溯

- 数据结构和算法

  可见，有什么样的数据结构就决定了可以用什么样的算法。

  那为什么不再建一个successor数组来保存每个点的后继呢？从DFS算法的过程可以看出，虽然每个点的前趋只有一个，后继却不止一个，如果我们为每个点只保存一个后继，则无法保证这个后继指向正确的路线。由此可见，有什么样的算法就决定了可以用什么样的数据结构。

  设计算法和设计数据结构这两件工作是紧密联系的。

## 12.4 队列与广度优先搜索

- 队列提供入队和出队两种操作

  队列也是一组元素的集合，也提供两种基本操作：Enqueue（入队）将元素添加到队尾，Dequeue（出队）从队头取出元素并返回。

- FIFO

  就像排队买票一样，先来先服务，先入队的也是先出队的，这种方式称为FIFO（First In First Out，先进先出），有时候队列本身也被称为FIFO。

- 广度优先搜索

## 12.5 环形队列

- 环形队列

  队列的head、tail指针都在一直增大，虽然前面的元素已经出队了，但它所占的存储空间却不能重复利用。

  一般情况下出队的元素就不再有保存价值了，这些元素的存储空间应该回收利用，由此想到把队列改造成环形队列（Circular Queue）：把queue数组想象成一个圈，head和tail指针仍然是一直增大的，当指到数组末尾时就自动回到数组开头，就像两个人围着操场赛跑，沿着它们跑的方向看，从head到tail之间是队列的有效元素，从tail到head之间是空的存储位置，如果head追上tail就表示队列空了，如果tail追上head就表示队列的存储空间满了，

- head 和 tail 一样

  “head和tail指向相同的位置”既可能表示“队列空”也可能表示“队列满”，这是肯定不行的，在实现环形队列时必须要区分这两种状态，请思考一下可以用哪些办法来区分。
