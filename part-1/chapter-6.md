# 6. 循环语句

## 6.1 while 语句

### 迭代

- 迭代：每次有一点区别的重复工作

  在第5.3节中，我们介绍了用递归求n!的方法，其实每次递归调用都在重复做同样一件事，就是把n乘到(n-1)!上然后把结果返回。

  虽说是重复，但每次做都稍微有一点区别（n的值不一样），这种每次都有一点区别的重复工作称为迭代（Iteration）。

- 计算机擅长迭代工作

  我们使用计算机的主要目的之一就是让它做重复迭代的工作，因为把一件工作重复做成千上万次而不出错正是计算机最擅长的，也是人类最不擅长的。

### while 语句

- 递归可以做迭代，但循环语句更方便

  虽然迭代用递归来做就够了，但C语言提供了循环语句使迭代程序写起来更方便。

- factorial 函数可以用 while 语句重写

  例如factorial用while语句可以写成：

  ``` c
  int factorial(int n)
  {
      int result = 1;
      while (n > 0) {
          result = result * n;
          n = n - 1;
      }
      return result;
  }
  ```

- while 语句语法

  和if语句类似，while语句由一个控制表达式和一个子语句组成，子语句可以是由若干条语句和声明组成的语句块。

  语句 → while (控制表达式) 语句

- 控制流程（循环）和循环体

  如果控制表达式的值为真，子语句就被执行，然后再次测试控制表达式的值，如果还是真，就把子语句再执行一遍，再测试控制表达式的值……

  这种控制流程称为循环（Loop），子语句称为**循环体**。

  如果某次测试控制表达式的值为假，就跳出循环执行后面的return语句，如果第一次测试控制表达式的值就是假，那么直接跳到return语句，循环体一次都不执行。

- 累加器和循环变量

  变量result在这个循环中的作用是累加器（Accumulator），把每次循环的中间结果累积起来，循环结束后得到的累积值就是最终结果，由于这个例子是用乘法来累积的，所以result的初值是1，如果用加法累积则result的初值应该是0。

  变量n是循环变量（Loop Variable），每次循环都要改变它的值，在控制表达式中要测试它的值，这两点合起来起到控制循环次数的作用，在这个例子中n的值是递减的，也有些循环采用递增的循环变量。

  这个例子具有一定的典型性，累加器和循环变量这两种模式在循环中都很常见。

### 比较递归和循环

可见，递归能解决的问题用循环也能解决，但解决问题的思路不一样。

- 有时候循环比递归容易理解

  用递归解决这个问题靠的是递推关系n!=n·(n-1)!，用循环解决这个问题则更像是把这个公式展开了：n!=n·(n-1)·(n-2)·…·3×2×1。

  把公式展开了理解会更直观一些，所以有些时候循环程序比递归程序更容易理解。

- 有时候递归比循环容易理解

  但也有一些公式要展开是非常复杂的甚至是不可能的，反倒是递推关系更直观一些，这种情况下递归程序比循环程序更容易理解。

- 函数式编程和命令式编程

  此外还有一点不同：看图5.2，在整个递归调用过程中，虽然分配和释放了很多变量，但所有变量都只在初始化时赋值，没有任何变量的值发生过改变，而上面的循环程序则通过对n和result这两个变量多次赋值来达到同样的目的。

  前一种思路称为函数式编程（Functional Programming），而后一种思路称为命令式编程（Imperative Programming），这个区别类似于第1.1节讲的Declarative和Imperative的区别。

  函数式编程的“函数”类似于数学函数的概念，回顾一下第3.1节所讲的，数学函数是没有Side Effect的，而C语言的函数可以有Side Effect，比如在一个函数中修改某个全局变量的值就是一种Side Effect。

  - 全局变量多次赋值会有麻烦，局部变量多次赋值也会有麻烦

    第3.4节指出，全局变量被多次赋值会给调试带来麻烦，如果一个函数体很长，控制流程很复杂，那么局部变量被多次赋值也会有同样的问题。

  - 很多语言完全采用函数式编程，避免变量多次赋值

    因此，不要以为“变量可以多次赋值”是天经地义的，有很多编程语言可以完全采用函数式编程的方式，避免Side Effect，例如LISP、Haskell、Erlang等。

  - C 语言主要还是命令式，但给变量多次赋值的时候也要小心，多次读写一个变量时要以一致的方式进行

    用C语言编程主要还是采用Imperative的方式，但要记住，给变量多次赋值时要格外小心，在代码中多次读写同一变量应该以一种一致的方式进行。所谓“一致的方式”是说应该有一套统一的规则，规定在一段代码中哪里会对某个全局变量赋值、哪里会读取它的值，比如在第24.2.4节会讲到访问errno的规则。

### 无穷循环（死循环）

递归函数如果写得不小心就会变成无穷递归，同样道理，循环如果写得不小心就会变成无限循环（Infinite Loop）或者叫死循环。

- 写循环时要注意控制表达式有没有可能取值为假

  如果while语句的控制表达式永远为真就成了一个死循环，例如while (1) {...}。

  在写循环时要小心检查你写的控制表达式有没有可能取值为假，除非你故意写死循环（有的时候这是必要的）。

  在上面的例子中，不管n一开始是几，每次循环都会把n减掉1，n越来越小最后必然等于0，所以控制表达式最后必然取值为假，但如果把n = n - 1;这句漏掉就成了死循环。

## 6.2 do/while 语句

### do/while 语句语法

do/while语句的语法是：

语句 → do 语句 while (控制表达式);

### 控制流程

while语句先测试控制表达式的值再执行循环体，而do/while语句先执行循环体再测试控制表达式的值。

如果控制表达式的值一开始就是假，while语句的循环体一次都不执行，而do/while语句的循环体仍然要执行一次再跳出循环。

### 其实 while 语句就够了，但是其他的循环语句有些时候方便些

其实只要有while循环就足够了，do/while循环和后面要讲的for循环都可以改写成while循环，只不过有些情况下用do/while或for循环写起来更简便，代码更易读。

### 循环变量 i、j、k

虽然变量名应该尽可能起得有意义一些，不过用i、j、k给循环变量起名是很常见的。

## 6.3 for 语句

### for 语句语法

前两节我们在while和do/while循环中使用循环变量，其实使用**循环变量最常见**的是for循环这种形式。

for语句的语法是：

语句 → for (控制表达式1; 控制表达式2; 控制表达式 3) 语句

- 等价的 while 循环

  如果不考虑循环体中包含continue语句的情况（稍后介绍continue语句），这个for循环等价于下面的while循环：

  ``` c
  控制表达式1;
  while (控制表达式2) {
      语句
      控制表达式3;
  }
  ```

- 控制表达式 1 和 3 可以为空，控制表达式 2 为空表示它的值为真

  从这种等价形式来看，控制表达式1和3都可以为空，但控制表达式2是必不可少的，例如for (;1;) {...}等价于while (1) {...}死循环。

  C语言规定，如果控制表达式2为空，则认为控制表达式2的值为真，因此死循环也可以写成for (;;) {...}。

### 自增运算符和自减运算符

- 前缀运算符

  其中++i这个表达式相当于i = i + 1，这两种写法在语义上稍有区别，详见第15.2.1节。

  ++称为前缀自增运算符（Prefix Increment Operator），类似地，--称为前缀自减运算符（Prefix Decrement Operator），--i相当于i=i-1。

  如果把++i这个表达式看作一个函数调用，除了传入一个参数返回一个值（等于参数值加1）之外，还产生一个Side Effect，就是把变量i的值增加了1。

- 后缀运算符

  ++和--运算符也可以用在变量后面，例如i++和i--，为了和前缀运算符区别，这两个运算符称为后缀自增运算符（Postfix Increment Operator）和后缀自减运算符（Postfix Decrement Operator）。

  如果把i++这个表达式看作一个函数调用，传入一个参数返回一个值，返回值就等于参数值（而不是参数值加1），此外也产生一个Side Effect，就是把变量i的值增加了1，它和++i的区别就在于返回值不同。

  同理，--i返回减1之后的值，而i--返回减1之前的值，但这两个表达式都产生同样的Side Effect，就是把变量i的值减了1。

- 自增自减运算符使程序简洁，但影响可读性

  使用++、--运算符会使程序更加简洁，但也会影响程序的可读性，参考文献[3]中的示例代码大量运用++、--和其他表达式的组合使得代码非常简洁。

  为了让初学者循序渐进，在接下来的几章中++、--运算符总是单独组成一个表达式而不跟其他表达式组合，从第11章开始将采用参考文献[3]的简洁风格。

- 如何理解 a+++++b

  我们看一个有意思的问题：a+++++b这个表达式如何理解？

  应该理解成a++ ++ +b还是a++ + ++b，还是a + ++ ++b呢？

  应该按第一种方式理解。

  - 编译过程分为词法解析和语法解析，最后做基本语义分析

    编译的过程分为词法解析和语法解析两个阶段，在词法解析阶段，编译器总是从前到后找最长的合法Token。把这个表达式从前到后解析，变量名a是一个Token，a后面有两个以上的+号，在C语言中一个+号是合法的Token（可以是加法运算符或正号），两个+号也是合法的Token（可以是自增运算符），根据最长匹配原则，编译器绝不会止步于一个+号，而一定会把两个+号当做一个Token。再往后解析仍然有两个以上的+号，所以又是一个++运算符。再往后解析只剩一个+号了，是加法运算符。再往后解析是变量名b。

    词法解析之后进入下一阶段语法解析，a是一个表达式，表达式++还是表达式，表达式再++还是表达式，表达式再+b还是表达式，语法上没有问题。

    最后编译器会做一些基本的语义分析，这时就有问题了，++运算符要求操作数能做左值，a能做左值所以a++没问题，但表达式a++的值只能做右值，不能再++了，所以最终编译器会报错。

### C99 规定的新 for 语句语法

C99规定了一种新的for循环语法（其实是从C++借鉴的），在控制表达式1的位置可以有变量定义。

例如上例的循环变量i可以只在for循环中定义：

``` c
int factorial(int n)
{
    int result = 1;
    for(int i = 1; i <= n; i++)
        result = result * i;
    return result;
}
```

如果这样定义，那么变量i只是for循环中的**局部变量**而不是整个函数的局部变量，相当于第4.1节讲过的**语句块中的局部变量**，在循环结束后就不能再使用i这个变量了。

注意这个程序用gcc编译时必须加上选项-std=c99。

## 6.4 break 和 continue 语句

- break 语句可以跳出switch语句块也可以跳出循环体

  在第4.4节中我们见到了break语句的一种用法，用来跳出switch语句块，这个语句也可以用来跳出循环体。

- continue 终止当前循环，执行下一次循环

  continue语句也会终止当前循环，和break语句不同的是，continue语句终止当前循环后又回到循环体的开头准备执行下一次循环。

  对于while循环和do/while循环，执行continue语句之后测试控制表达式，如果值为真则继续执行下一次循环；

  对于for循环，执行continue语句之后首先计算控制表达式3，然后测试控制表达式2，如果值为真则继续执行下一次循环。

## 6.5 嵌套循环

在有多层循环或switch嵌套的情况下，break只能跳出最内层的循环或switch，continue也只能终止最内层循环并回到该循环的开头。

## 6.6 goto 语句和标号

### goto 语句

- goto 语句实现无条件跳转

  分支、循环都讲完了，现在只剩下最后一种影响控制流程的语句了，就是goto语句，实现无条件跳转。

- 例子

  我们知道break只能跳出最内层的循环，如果在一个嵌套循环中遇到某个错误条件需要立即跳出最外层循环做出错处理，就可以用goto语句，例如：

  ``` c
  for (...)
      for (...) {
          ...
          if (出现错误条件)
              goto error;
      }
  error:
      出错处理;
  ```

- 标号

  这里的error:叫做标号（Label），任何语句前面都可以加若干个标号，每个标号的命名也要遵循标识符的命名规则。

- goto 语句只能在同一个函数中进行无条件跳转

  goto语句过于强大了，从程序中的任何地方都可以无条件跳转到任何其他地方，只要在那个地方定义一个标号就行，唯一的限制是goto只能跳转到同一个函数中的某个标号处，而不能跳到别的函数中。

- 别的方法可以实现函数间的跳转，但也只能跳回直接或间接调用者

  C标准库函数setjmp和longjmp配合起来可以实现函数间的跳转，但只能从被调用的函数跳回到它的直接或间接调用者（同时从栈空间弹出一个或多个栈帧），而不能从一个函数跳转到另一个和它毫不相干的函数中。

  setjmp/longjmp函数主要也是用于出错处理，比如函数A调用函数B，函数B调用函数C，如果在C中出现某个错误条件，使得函数B和C继续执行下去都没有意义了，可以利用setjmp/longjmp机制快速返回到函数A做出错处理，本书不详细介绍这种机制，有兴趣的读者可查阅参考文献[31]的7.10节和10.15节。

- 除了以下例子，不要轻易使用 goto 语句

  滥用goto语句会使程序的控制流程非常复杂，可读性很差。

  著名的计算机科学家Edsger W. Dijkstra最早指出编程语言中goto语句的危害，提倡取消goto语句。

  goto语句不是必须存在的，显然可以用别的办法替代，比如上面的代码段可以改写为：

  ``` c
  int cond = 0;
  for (...) {
      for (...) {
          ...
          if (出现错误条件) {
              cond = 1;
              break;
          }
      }
      if (cond)
          break;
  }
  if (cond)
      出错处理;
  ```

  通常goto语句只用于这种场合，一个函数中任何地方出现了错误条件都可以立即跳转到函数末尾做出错处理（例如释放先前分配的资源、恢复先前改动过的全局变量等），处理完之后函数返回。

  比较用goto和不用goto的两种写法，用goto语句还是方便很多。

  但是除此之外，在任何其他场合都不要轻易考虑使用goto语句。

- 有些编程语言中有异常处理

  有些编程语言（如C++）中有异常（Exception）处理的语法，可以代替goto和setjmp/longjmp的这种用法。

### 标号

- case 和 default 也是特殊的标号

  回想一下，我们在第4.4节学过case和default后面也要跟冒号（:号，Colon），事实上它们是两种特殊的标号。

- 和标号有关的语法规则

  和标号有关的语法规则如下：

  语句 → 标识符: 语句
  语句 → case 常量表达式: 语句
  语句 → default: 语句

- 一条语句前面多个标号

  反复应用这些语法规则进行组合可以在一条语句前面添加多个标号，例如在例4.2的代码中，有些语句前面有多个case标号。

- 改写 switch 语句语法：switch 语句里也可以有声明

  现在我们再看switch语句的格式：

  ``` c
  switch (控制表达式) {
  case 常量表达式: 零条或多条语句
  case 常量表达式: 零条或多条语句
  ...
  default: 零条或多条语句
  }
  ```

  {}里面是一组语句列表，其中每个分支的第一条语句带有case或default标号，从语法上来说，switch的语句块和其他分支、循环结构的语句块没有本质区别，因此前面的语法规则可以改写为：

  语句 → switch (控制表达式) 语句

  语句 → { 语句列表 }

  改写后的语法规则更为准确，我们知道{}中的语句列表不仅可以包含语句，还可以包含**声明**，而前面的语法规则并没有体现出这一点。

  - 语句才能带标号，声明不能

    但要注意，只有语句前面才能带标号，声明前面不能带标号，例如这样写是错的：

    ``` c
    case 1: int i = 10;
    ```

    但这样写是对的：

    ``` c
    case 1: {int i = 10; }
    ```

    这样写也是对的：

    ``` c
    case 1: ; int i = 10;
    ```

  - 特殊例子

    再比如这样的switch语句：

    ``` c
    switch (n) {
        int i = 10;
    case 1:
        printf("%d\n", i * 1);
        break;
    case 2:
        printf("%d\n", i * 2);
        break;
    }
    ```

    这段代码从语法上看是对的，从语义上看却有一个陷阱。变量i在switch语句块中定义，但并不会初始化成10，因为不管n的值是几，进入switch语句块都会跳过给i赋初值的指令，从某一个case标号开始执行。
